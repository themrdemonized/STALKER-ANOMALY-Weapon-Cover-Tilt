-- Weapon cover tilt script
-- Makes weapon go up when near obstacle to emulate weapon dimensions 
-- Written by demonized

--Protected function call to prevent crashes to desktop
--Prints error in console if occured, otherwise proceed normally
--Use for test only, slower than usual
local try = try or function(func, ...)
	local status, error_or_result = pcall(func, ...)
	if not status then
		printf(error_or_result)
		return false, status, error_or_result
	else
		return error_or_result, status
	end
end

--EMA smoothing for changing values
local default_smoothing = 13
local smoothed_values = {}

local function ema(key, value, def, steps, delta)
	local steps = steps or default_smoothing
	local delta = delta or steps
	local smoothing_alpha = 2.0 / (steps + 1)

	smoothed_values[key] = smoothed_values[key] and smoothed_values[key] + smoothing_alpha * (delta / steps) * (value - smoothed_values[key]) or def or value

	--printf("EMA fired, key %s, target %s, current %s, going %s", key, value, smoothed_values[key], (value > smoothed_values[key] and "up" or "down"))
	return smoothed_values[key]
end

local function lerp(a, b, f)
	if (a and b and f) then
		return (1 - f) * a + (f * b)
	else
		return a or b or 0
	end
end

local parameters = {
-- Type: 0 = string | 1 = number | 2 = 3d vector | 3 = 4d vector | 
	["hands_position"]		            = { name = "Hands Position",         typ = 2, def = {0,0,0}, indx = 1,  min = -180,   max = 180, step = 0.00001, idxa = 0, idxb = 0,  hud = true },
	["hands_orientation"]	            = { name = "Hands Orientation",      typ = 2, def = {0,0,0}, indx = 2,  min = -180,   max = 180, step = 0.00001, idxa = 1, idxb = 0,  hud = true },
	["aim_hud_offset_pos"]		        = { name = "Aim Position",           typ = 2, def = {0,0,0}, indx = 3,  min = -180,   max = 180, step = 0.00001, idxa = 0, idxb = 1,  hud = true },
	["aim_hud_offset_rot"]	            = { name = "Aim Orientation",        typ = 2, def = {0,0,0}, indx = 4,  min = -180,   max = 180, step = 0.00001, idxa = 1, idxb = 1,  hud = true },
	["gl_hud_offset_pos"]		        = { name = "GL Position",            typ = 2, def = {0,0,0}, indx = 5,  min = -180,   max = 180, step = 0.00001, idxa = 0, idxb = 2,  hud = true },
	["gl_hud_offset_rot"]		        = { name = "GL Orientation",         typ = 2, def = {0,0,0}, indx = 6,  min = -180,   max = 180, step = 0.00001, idxa = 1, idxb = 2,  hud = true },
	["aim_hud_offset_alt_pos"]	        = { name = "Alt Position",           typ = 2, def = {0,0,0}, indx = 7,  min = -180,   max = 180, step = 0.00001, idxa = 0, idxb = 3,  hud = true },
	["aim_hud_offset_alt_rot"]			= { name = "Alt Orientation",        typ = 2, def = {0,0,0}, indx = 8,  min = -180,   max = 180, step = 0.00001, idxa = 1, idxb = 3,  hud = true },
	["fire_point"]	        			= { name = "Fire Point",           	 typ = 2, def = {0,0,0}, indx = 9,  min = -180,   max = 180, step = 0.00001, idxa = 0, idxb = 10, hud = true, no_16x9 = true },
	["fire_point2"]	       				= { name = "Fire Point 2",           typ = 2, def = {0,0,0}, indx = 10, min = -180,   max = 180, step = 0.00001, idxa = 0, idxb = 11, hud = true, no_16x9 = true },
	["fire_direction"]					= { name = "Fire Direction",         typ = 2, def = {0,0,1}, indx = 11, min = -180,   max = 180, step = 0.00001, idxa = 1, idxb = 10, hud = true, no_16x9 = true },
	["shell_point"]						= { name = "Shell Point",        	 typ = 2, def = {0,0,0}, indx = 12, min = -180,   max = 180, step = 0.00001, idxa = 1, idxb = 11, hud = true, no_16x9 = true },
	["custom_ui_pos"]	       		 	= { name = "UI Position",            typ = 2, def = {0,0,0}, indx = 13, min = -180,   max = 180, step = 0.00001, idxa = 0, idxb = 20 }, --idxb 20 is reserved for device ui
	["custom_ui_rot"]					= { name = "UI Orientation",         typ = 2, def = {0,0,0}, indx = 14, min = -180,   max = 180, step = 1, 		 idxa = 1, idxb = 20 },
	["lowered_hud_offset_pos"]			= { name = "Lowered Position",       typ = 2, def = {0,0,0}, indx = 15, min = -180,   max = 180, step = 0.00001, idxa = 0, idxb = 4,  hud = true },
	["lowered_hud_offset_rot"]			= { name = "Lowered Orientation",    typ = 2, def = {0,0,0}, indx = 16, min = -180,   max = 180, step = 0.00001, idxa = 1, idxb = 4,  hud = true },
	["scope_zoom_factor"]				= { name = "Zoom Factor",        	 typ = 1, def = 0, 		 indx = 17, min = 0,  	  max = 120, step = 0.1 },
	["gl_zoom_factor"]					= { name = "GL Zoom Factor",         typ = 1, def = 0, 		 indx = 18, min = 0,  	  max = 120, step = 0.1 },
	["scope_zoom_factor_alt"]			= { name = "Alt Zoom Factor",        typ = 1, def = 0, 		 indx = 19, min = 0,  	  max = 120, step = 0.1 }, 
}

function reset_wpn_hud(sec)
	local hud_sec = SYS_GetParam(0, sec, "hud")
	if not hud_sec then return end

	hud_adjust.enabled(true)
	for k, v in pairs(parameters) do
		if v.typ == 1 then
			local p = SYS_GetParam(2, hud_sec, k, v.def)
			if p then
				hud_adjust.set_value(k, p)
			end
		elseif v.typ == 2 then
			local function res(str)
				local str = str or ""
				local p = SYS_GetParam(0, hud_sec, v.no_16x9 and k or (k .. str))

				if not p then
					p = table.concat(v.def, ",")
				end

				if p then
					p = str_explode(p, ",")
					for i, d in ipairs(v.def) do
						p[i] = p[i] and tonumber(p[i]) or d
					end
					hud_adjust.set_vector(v.idxa, v.idxb, p[1] or 0, p[2] or 0, p[3] or 0)
				end
			end
			res(utils_xml.is_widescreen() and "_16x9")
		end
	end
	hud_adjust.enabled(false)
end

local max_dist = 1.0
local max_deg = 75
local random_funcs = demonized_randomizing_functions
local wpn_positions = weapon_cover_tilt_positions

-- Sections of weapons that have kind "pistol" but they arent pistols
not_pistol_sec = {
	wpn_svt40_short = true,
	wpn_avt40_short = true,
	wpn_aek919k = true,
}

local weapon_table = {}
function add_to_weapon_table(sec)
	weapon_table[sec] = {
		hands_position = (function()
			local hud_sec = SYS_GetParam(0, sec, "hud")
			local c = str_explode(utils_xml.is_widescreen() and SYS_GetParam(0, hud_sec, "hands_position_16x9") or SYS_GetParam(0, hud_sec, "hands_position") or "0,0,0", ",")
			return {
				[0] = tonumber(c[1]) or 0,
				[1] = tonumber(c[2]) or 0,
				[2] = tonumber(c[3]) or 0,
			}
		end)(),
		hands_orientation = (function()
			local hud_sec = SYS_GetParam(0, sec, "hud")
			local c = str_explode(utils_xml.is_widescreen() and SYS_GetParam(0, hud_sec, "hands_orientation_16x9") or SYS_GetParam(0, hud_sec, "hands_orientation") or "0,0,0", ",")
			return {
				[0] = tonumber(c[1]) or 0,
				[1] = tonumber(c[2]) or 0,
				[2] = tonumber(c[3]) or 0,
			}
		end)(),
		inv_weight = SYS_GetParam(2, sec, "inv_weight", 0),
	}
end

local target_pos = {
	hands_position_pistol = {
		[0] = -0.050912,
		[1] = -0.696908,
		[2] = 0.260633,
	},
	hands_position_rifle = {
		[0] = 0.055224,
		[1] = -0.6,
		[2] = 0.122598,
	}
}

local tilt_enabled = false
local firepos_state = 0

function enable_tilt(sec, wpn)
	local weapon_zoomed = axr_main.scoped_weapon_is_zoomed
	if weapon_zoomed then
		if (get_console():get_bool("wpn_aim_toggle")) then
			level.press_action(bind_to_dik(key_bindings.kWPN_ZOOM))
		else
			level.release_action(bind_to_dik(key_bindings.kWPN_ZOOM))
		end
	end

	if not tilt_enabled then
		-- Dirty AF hack to reset position (unused)
		-- local wpn_hud = ui_debug_wpn_hud.WpnHudEditor(nil, sec)
		-- if wpn_hud then
		-- 	wpn_hud:Reset(true)
		-- 	wpn_hud:Close()
		-- end
		reset_wpn_hud(sec)

		hud_adjust.enabled(true)
		set_weapon_position(sec, weapon_table[sec].hands_position, weapon_table[sec].hands_orientation)
		exec_console_cmd("g_firepos 1")
		tilt_enabled = true
	end
end

function reset(sec)
	if tilt_enabled then
		if sec and weapon_table[sec] then reset_wpn_hud(sec) end
		hud_adjust.enabled(false)
		exec_console_cmd("g_firepos " .. (firepos_state or 0))
		smoothed_values.hands_position_x = nil
		smoothed_values.hands_position_y = nil
		smoothed_values.hands_position_z = nil
		smoothed_values.hands_orientation_x = nil
		smoothed_values.hands_orientation_y = nil
		smoothed_values.hands_orientation_z = nil
		tilt_enabled = false
	end
end

-- Get steps depending on inv_weight, heavier guns have less movement speed
function get_weapon_weight(wpn, sec)
	local cobj = wpn:cast_Weapon()
	local weight = clamp(cobj and cobj:Weight() or (weapon_table[sec] and weapon_table[sec].inv_weight or 0), 0, 20)
	return weight
end

function get_weapon_steps(wpn, sec)
	return default_smoothing * (1 + get_weapon_weight(wpn, sec) * 0.09)
end

function set_weapon_position(sec, new_pos, new_ori)
	-- printf("old_pos for %s: %s, %s, %s", sec, weapon_table[sec].hands_position[0], weapon_table[sec].hands_position[1], weapon_table[sec].hands_position[2])
	-- printf("new_pos for %s: %s, %s, %s", sec, new_pos[0], new_pos[1], new_pos[2])
	-- printf("old_ori for %s: %s, %s, %s", sec, weapon_table[sec].hands_orientation[0], weapon_table[sec].hands_orientation[1], weapon_table[sec].hands_orientation[2])
	-- printf("new_pri for %s: %s, %s, %s", sec, new_ori[0], new_ori[1], new_ori[2])

	hud_adjust.set_vector(0, 0, new_pos[0] or 0, new_pos[1] or 0, new_pos[2] or 0)
	hud_adjust.set_vector(1, 0, new_ori[0] or 0, new_ori[1] or 0, new_ori[2] or 0)
	-- hud_adjust.set_vector(parameters[parent].idxa, parameters[parent].idxb, value_1, value_2, value_3)
end

function soft_reset(wpn, sec, delta)
	if not weapon_table[sec] then return reset(sec) end

	if tilt_enabled then
		-- Increase speed of return to position when closer to it for zoomed weapons
		local cobj = wpn:cast_Weapon()
		local is_scoped = cobj and cobj:IsScopeAttached()
		local k = is_scoped and normalize(smoothed_values.hands_orientation_y, weapon_table[sec].hands_orientation[1], max_deg) ^ 0.12 or 1

		-- printf("cur %s, min %s, max %s, %s", smoothed_values.hands_orientation_y, weapon_table[sec].hands_orientation[1], max_deg, k)
		local steps = get_weapon_steps(wpn, sec) * k

		local new_pos = {
			[0] = ema("hands_position_x", weapon_table[sec].hands_position[0], weapon_table[sec].hands_position[0], steps, delta),
			[1] = ema("hands_position_y", weapon_table[sec].hands_position[1], weapon_table[sec].hands_position[1], steps, delta),
			[2] = ema("hands_position_z", weapon_table[sec].hands_position[2], weapon_table[sec].hands_position[2], steps, delta),
		}

		local new_ori = {
			[0] = weapon_table[sec].hands_orientation[0],
			[1] = ema("hands_orientation_y", weapon_table[sec].hands_orientation[1], weapon_table[sec].hands_orientation[1], steps, delta),
			[2] = weapon_table[sec].hands_orientation[2],
		}

		set_weapon_position(sec, new_pos, new_ori)

		local weapon_zoomed = axr_main.scoped_weapon_is_zoomed
		if weapon_zoomed then
			if (get_console():get_bool("wpn_aim_toggle")) then
				level.press_action(bind_to_dik(key_bindings.kWPN_ZOOM))
			else
				level.release_action(bind_to_dik(key_bindings.kWPN_ZOOM))
			end
		end

		for i = 0, 2, 1 do
			if 	math.abs(new_pos[i] - weapon_table[sec].hands_position[i]) > 0.06
			or 	math.abs(new_ori[i] - weapon_table[sec].hands_orientation[i]) > 0.06
			then
				return
			end
		end

		-- printf("soft reset complete")
		reset(sec)
	end
end

function actor_on_update(binder, delta)
	local actor = db.actor

	-- Cancel if PDA is active
	if actor:active_slot() == 8 then
		return reset()
	end

	local wpn = actor:active_item()

	-- printf("%s", delta)

	-- Reset if no wpn
	if not wpn then
		return reset()
	end

	local sec = wpn:section()
	local hud_sec = SYS_GetParam(0, sec, "hud")

	-- Reset when no hud sec
	if not hud_sec then
		return reset(sec)
	end

	-- Reset if melee weapon
	if IsMelee(wpn) or IsItem("fake_ammo_wpn", sec) then
		return reset(sec)
	end

	-- Reset if throwable weapon (grenade, bolt)
	if IsBolt(wpn) or IsGrenade(wpn) then
		return reset(sec)
	end

	-- Add to weapon table
	if not weapon_table[sec] then
		add_to_weapon_table(sec)
	end

	-- Soft reset if weapon is lowered
	if game.actor_weapon_lowered() then
		return soft_reset(wpn, sec, delta)
	end

	-- Cancel if detector is active
	if actor:active_detector() then
		return soft_reset(wpn, sec, delta)
	end

	-- Soft reset if hiding weapon or reloading
	local state = wpn:get_state()
	if state == 2 or state == 7 then
		return soft_reset(wpn, sec, delta)
	end

	-- Get target dist
	local dist = math.max(0, level.get_target_dist() - 0.5)

	-- Get max dist based on weapon
	local max_dist = SYS_GetParam(0, sec, "kind", "") == "w_pistol" and max_dist - 0.35 or max_dist

	-- Soft reset if distance is more than max_dist
	if dist > max_dist then
		return soft_reset(wpn, sec, delta)
	end

	-- Soft reset if target is enemy stalker or monster
	local target_obj = level.get_target_obj()
	if target_obj then
		if IsMonster(target_obj) then
			return soft_reset(wpn, sec, delta)
		elseif IsStalker(target_obj) and xr_combat_ignore.is_enemy(actor, target_obj, true) then
			return soft_reset(wpn, sec, delta)
		end
	end

	-- Apply non linear coefficient
	local coeff = random_funcs.CircularEaseOut(1 - dist / max_dist)
	-- printf("coeff %s, dist %s, max_dist %s", coeff, dist, max_dist)

	-- Calculate new position
	local position_coeff_y = -0.445
	local position_coeff_z = 0.485

	-- Get steps depending on inv_weight, heavier guns have less movement speed
	local steps = get_weapon_steps(wpn, sec)
	
	local new_pos
	if wpn_positions.weapon_positions[sec] then
		local p = wpn_positions.weapon_positions[sec]
		new_pos = {
			[0] = lerp(weapon_table[sec].hands_position[0], p.x or weapon_table[sec].hands_position[0], coeff),
			[1] = lerp(weapon_table[sec].hands_position[1], p.y or weapon_table[sec].hands_position[1], coeff),
			[2] = lerp(weapon_table[sec].hands_position[2], p.z or weapon_table[sec].hands_position[2], coeff ^ 4),
		}
	else
		-- Check for scopes on weapons
		local base_sec = sec
		if not wpn_positions.weapon_offsets[base_sec] then
			local parent = SYS_GetParam(0, base_sec, "parent_section", base_sec)
			local scopes = str_explode(SYS_GetParam(0, parent, "scopes", ""), ",")
			for k, v in pairs(scopes) do
				if (parent .. "_" .. v) == base_sec then
					base_sec = parent
					break
				end
			end
		end

		local o = {
			[0] = wpn_positions.weapon_offsets[base_sec] and wpn_positions.weapon_offsets[base_sec].x or 0,
			[1] = wpn_positions.weapon_offsets[base_sec] and wpn_positions.weapon_offsets[base_sec].y or 0,
			[2] = wpn_positions.weapon_offsets[base_sec] and wpn_positions.weapon_offsets[base_sec].z or 0,
		}

		-- Interpolate between offseted position and desirable closer to obstacle, looks better, mostly
		local is_pistol = SYS_GetParam(0, base_sec, "kind", "") == "w_pistol" and not not_pistol_sec[base_sec]
		
		-- Different calculations for pistols
		if is_pistol then
			local target_pos = target_pos.hands_position_pistol 

			-- local a = {
			-- 	[0] = weapon_table[sec].hands_position[0] + o[0] * coeff,
			-- 	[1] = weapon_table[sec].hands_position[1] + (o[1] + position_coeff_y) * coeff,
			-- 	[2] = weapon_table[sec].hands_position[2] + (o[2] + position_coeff_z) * coeff ^ 2,
			-- }

			local b = {
				[0] = lerp(weapon_table[sec].hands_position[0], (o[0] + weapon_table[sec].hands_position[0]), coeff),
				[1] = lerp(weapon_table[sec].hands_position[1], (o[1] + target_pos[1]), coeff ^ 0.8),
				[2] = lerp(weapon_table[sec].hands_position[2], (o[2] + target_pos[2]), coeff ^ 2),
			}

			-- local c = {
			-- 	[0] = lerp(b[0], b[0], coeff),
			-- 	[1] = lerp(b[1], b[1], coeff),
			-- 	[2] = lerp(b[2], b[2], coeff ^ 2),
			-- }

			new_pos = b
		else
			local target_pos = target_pos.hands_position_rifle

			local a = {
				[0] = weapon_table[sec].hands_position[0] + o[0] * coeff,
				[1] = weapon_table[sec].hands_position[1] + (o[1] + position_coeff_y) * coeff,
				[2] = weapon_table[sec].hands_position[2] + (o[2] + position_coeff_z) * coeff ^ 4,
			}

			local b = {
				[0] = lerp(weapon_table[sec].hands_position[0], (o[0] + weapon_table[sec].hands_position[0]), coeff),
				[1] = lerp(weapon_table[sec].hands_position[1], (o[1] + target_pos[1]), coeff),
				[2] = lerp(weapon_table[sec].hands_position[2], (o[2] + target_pos[2]), coeff ^ 4),
			}

			local c = {
				[0] = lerp(a[0], b[0], coeff),
				[1] = lerp(a[1], b[1], coeff),
				[2] = lerp(a[2], b[2], coeff ^ 4),
			}

			new_pos = c
		end
	end

	-- Smooth new position
	new_pos = {
		[0] = ema("hands_position_x", new_pos[0], weapon_table[sec].hands_position[0], steps, delta),
		[1] = ema("hands_position_y", new_pos[1], weapon_table[sec].hands_position[1], steps, delta),
		[2] = ema("hands_position_z", new_pos[2], weapon_table[sec].hands_position[2], steps, delta),
	}

	local new_ori = {
		[0] = weapon_table[sec].hands_orientation[0],
		[1] = ema("hands_orientation_y", weapon_table[sec].hands_orientation[1] + max_deg * coeff, weapon_table[sec].hands_orientation[1], steps, delta),
		[2] = weapon_table[sec].hands_orientation[2],
	}

	-- Adjust hud
	enable_tilt(sec, wpn)
	set_weapon_position(sec, new_pos, new_ori)

	-- printf("target_dist %s", dist)
end

function actor_on_first_update()
	-- firepos_state = get_console_cmd(0, "g_firepos")
	firepos_state = 0
end

function on_game_start()
	RegisterScriptCallback("actor_on_before_death", reset)
	RegisterScriptCallback("actor_on_net_destroy", reset)
	RegisterScriptCallback("on_before_level_changing", reset)
	RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
	RegisterScriptCallback("actor_on_update", actor_on_update)
end
