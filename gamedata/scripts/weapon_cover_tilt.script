-- Weapon cover tilt script
-- Makes weapon go up when near obstacle to emulate weapon dimensions 
-- Written by demonized

--Protected function call to prevent crashes to desktop
--Prints error in console if occured, otherwise proceed normally
--Use for test only, slower than usual
local try = try or function(func, ...)
	local status, error_or_result = pcall(func, ...)
	if not status then
		printf(error_or_result)
		return false, status, error_or_result
	else
		return error_or_result, status
	end
end

local normalize = normalize
local clamp = clamp

local abs = math.abs
local min = math.min
local max = math.max
local sqrt = math.sqrt

local actor_weapon_lowered = game.actor_weapon_lowered

local get_target_dist = level.get_target_dist
local get_target_obj = level.get_target_obj

--EMA smoothing for changing values, frame independent
local default_smoothing = 11.5
local smoothed_values = {}

local function ema(key, value, def, steps, delta)
	local steps = steps or default_smoothing
	local delta = delta or steps
	local smoothing_alpha = 2.0 / (steps + 1)

	smoothed_values[key] = smoothed_values[key] and smoothed_values[key] + min(smoothing_alpha * (delta / steps), 1) * (value - smoothed_values[key]) or def or value

	--printf("EMA fired, key %s, target %s, current %s, going %s", key, value, smoothed_values[key], (value > smoothed_values[key] and "up" or "down"))
	return smoothed_values[key]
end

local function lerp(a, b, f)
	if (a and b and f) then
		return (1 - f) * a + (f * b)
	else
		return a or b or 0
	end
end

-- MCM
-- Load the defaults
local function load_defaults()
	local t = {}
	local op = weapon_cover_tilt_mcm.op
	for i, v in ipairs(op.gr) do
		if v.def ~= nil then
			t[v.id] = v.def
		end
	end
	return t
end

local settings = load_defaults()

local function load_settings()
	settings = load_defaults()
	if ui_mcm then
		for k, v in pairs(settings) do
			settings[k] = ui_mcm.get("weapon_cover_tilt/" .. k)
		end
	end
end

function debug_enabled()
	return DEV_DEBUG or DEV_DEBUG_DEV
end

local parameters = {
-- Type: 0 = string | 1 = number | 2 = 3d vector | 3 = 4d vector | 
	["hands_position"]		            = { name = "Hands Position",         typ = 2, def = {0,0,0}, indx = 1,  min = -180,   max = 180, step = 0.00001, idxa = 0, idxb = 0,  hud = true },
	["hands_orientation"]	            = { name = "Hands Orientation",      typ = 2, def = {0,0,0}, indx = 2,  min = -180,   max = 180, step = 0.00001, idxa = 1, idxb = 0,  hud = true },
	["aim_hud_offset_pos"]		        = { name = "Aim Position",           typ = 2, def = {0,0,0}, indx = 3,  min = -180,   max = 180, step = 0.00001, idxa = 0, idxb = 1,  hud = true },
	["aim_hud_offset_rot"]	            = { name = "Aim Orientation",        typ = 2, def = {0,0,0}, indx = 4,  min = -180,   max = 180, step = 0.00001, idxa = 1, idxb = 1,  hud = true },
	["gl_hud_offset_pos"]		        = { name = "GL Position",            typ = 2, def = {0,0,0}, indx = 5,  min = -180,   max = 180, step = 0.00001, idxa = 0, idxb = 2,  hud = true },
	["gl_hud_offset_rot"]		        = { name = "GL Orientation",         typ = 2, def = {0,0,0}, indx = 6,  min = -180,   max = 180, step = 0.00001, idxa = 1, idxb = 2,  hud = true },
	["aim_hud_offset_alt_pos"]	        = { name = "Alt Position",           typ = 2, def = {0,0,0}, indx = 7,  min = -180,   max = 180, step = 0.00001, idxa = 0, idxb = 3,  hud = true },
	["aim_hud_offset_alt_rot"]			= { name = "Alt Orientation",        typ = 2, def = {0,0,0}, indx = 8,  min = -180,   max = 180, step = 0.00001, idxa = 1, idxb = 3,  hud = true },
	["fire_point"]	        			= { name = "Fire Point",           	 typ = 2, def = {0,0,0}, indx = 9,  min = -180,   max = 180, step = 0.00001, idxa = 0, idxb = 10, hud = true, no_16x9 = true },
	["fire_point2"]	       				= { name = "Fire Point 2",           typ = 2, def = {0,0,0}, indx = 10, min = -180,   max = 180, step = 0.00001, idxa = 0, idxb = 11, hud = true, no_16x9 = true },
	["fire_direction"]					= { name = "Fire Direction",         typ = 2, def = {0,0,1}, indx = 11, min = -180,   max = 180, step = 0.00001, idxa = 1, idxb = 10, hud = true, no_16x9 = true },
	["shell_point"]						= { name = "Shell Point",        	 typ = 2, def = {0,0,0}, indx = 12, min = -180,   max = 180, step = 0.00001, idxa = 1, idxb = 11, hud = true, no_16x9 = true },
	["custom_ui_pos"]	       		 	= { name = "UI Position",            typ = 2, def = {0,0,0}, indx = 13, min = -180,   max = 180, step = 0.00001, idxa = 0, idxb = 20 }, --idxb 20 is reserved for device ui
	["custom_ui_rot"]					= { name = "UI Orientation",         typ = 2, def = {0,0,0}, indx = 14, min = -180,   max = 180, step = 1, 		 idxa = 1, idxb = 20 },
	["lowered_hud_offset_pos"]			= { name = "Lowered Position",       typ = 2, def = {0,0,0}, indx = 15, min = -180,   max = 180, step = 0.00001, idxa = 0, idxb = 4,  hud = true },
	["lowered_hud_offset_rot"]			= { name = "Lowered Orientation",    typ = 2, def = {0,0,0}, indx = 16, min = -180,   max = 180, step = 0.00001, idxa = 1, idxb = 4,  hud = true },
	["scope_zoom_factor"]				= { name = "Zoom Factor",        	 typ = 1, def = 0, 		 indx = 17, min = 0,  	  max = 120, step = 0.1 },
	["gl_zoom_factor"]					= { name = "GL Zoom Factor",         typ = 1, def = 0, 		 indx = 18, min = 0,  	  max = 120, step = 0.1 },
	["scope_zoom_factor_alt"]			= { name = "Alt Zoom Factor",        typ = 1, def = 0, 		 indx = 19, min = 0,  	  max = 120, step = 0.1 }, 
}

function reset_wpn_hud(sec)
	local hud_sec = SYS_GetParam(0, sec, "hud")
	if not hud_sec then return end

	hud_adjust.enabled(true)
	for k, v in pairs(parameters) do
		if v.typ == 1 then
			local p = SYS_GetParam(2, hud_sec, k, v.def)
			if p then
				hud_adjust.set_value(k, p)
			end
		elseif v.typ == 2 then
			local function res(str)
				local str = str or ""
				local p = SYS_GetParam(0, hud_sec, v.no_16x9 and k or (k .. str))

				if not p then
					p = table.concat(v.def, ",")
				end

				if p then
					p = str_explode(p, ",")
					for i, d in ipairs(v.def) do
						p[i] = p[i] and tonumber(p[i]) or d
					end
					hud_adjust.set_vector(v.idxa, v.idxb, p[1] or 0, p[2] or 0, p[3] or 0)
				end
			end
			res(utils_xml.is_widescreen() and "_16x9")
		end
	end
	hud_adjust.enabled(false)
end

function IsBinoc(sec)
	return 	SYS_GetParam(0, sec, "ammo_class", "") == "ammo_binoc"
	or 		SYS_GetParam(0, sec, "class", "") == "WP_BINOC"
end

local scoped_weapon_zoomed = false
function isScopedWeapon(wpn)
	if not wpn then return false end

	-- If there is fixed scope or no scope defined, but also if there is a scope texture, it will use the texture for zoomin and considered a scoped weapon
	if (wpn:weapon_scope_status() == 1 or wpn:weapon_scope_status() == 0) and SYS_GetParam(0, wpn:section(), "scope_texture", "") ~= "" then
		return true
	end

	-- Usual check
	local cobj = wpn:cast_Weapon()
	if (cobj and cobj:IsScopeAttached() or wpn:weapon_is_scope()) and SYS_GetParam(0, wpn:section(), "scope_texture", "") ~= "" then
		return true
	end

	return false
end

local max_deg = 75
local random_funcs = demonized_randomizing_functions
local wpn_positions = weapon_cover_tilt_positions or {}
local wpn_radii = weapon_cover_tilt_gun_trigger_radii and weapon_cover_tilt_gun_trigger_radii.weapon_trigger_radii or {}

-- Sections of weapons that have kind "pistol" but they arent pistols
not_pistol_sec = {
	wpn_svt40_short = true,
	wpn_avt40_short = true,
	wpn_aek919k = true,
}

local weapon_table = {}
function add_to_weapon_table(sec)
	weapon_table[sec] = {
		hands_position = (function()
			local hud_sec = SYS_GetParam(0, sec, "hud")
			local c = str_explode(utils_xml.is_widescreen() and SYS_GetParam(0, hud_sec, "hands_position_16x9") or SYS_GetParam(0, hud_sec, "hands_position") or "0,0,0", ",")
			return {
				[0] = tonumber(c[1]) or 0,
				[1] = tonumber(c[2]) or 0,
				[2] = tonumber(c[3]) or 0,
			}
		end)(),
		hands_orientation = (function()
			local hud_sec = SYS_GetParam(0, sec, "hud")
			local c = str_explode(utils_xml.is_widescreen() and SYS_GetParam(0, hud_sec, "hands_orientation_16x9") or SYS_GetParam(0, hud_sec, "hands_orientation") or "0,0,0", ",")
			return {
				[0] = tonumber(c[1]) or 0,
				[1] = tonumber(c[2]) or 0,
				[2] = tonumber(c[3]) or 0,
			}
		end)(),
		inv_weight = SYS_GetParam(2, sec, "inv_weight", 0),
	}
end

local target_pos = {
	hands_position_pistol = {
		[0] = -0.050912,
		[1] = -0.646908,
		[2] = 0.310633,
	},
	hands_position_rifle = {
		[0] = 0.055224,
		[1] = -0.6,
		[2] = 0.122598,
	}
}

local tilt_enabled = false
local firepos_state = 0
local yaw
local roll

function randomize_roll_yaw()
	if not yaw then
		local max_yaw = settings.yaw_variation
		yaw = random_float(-max_yaw, max_yaw)
	end

	if not roll then
		local max_roll = settings.roll_variation
		roll = random_float(-max_roll, max_roll * 0.33)
	end
end

function remove_roll_yaw()
	yaw = nil
	roll = nil
end

function enable_tilt(sec, wpn)
	if scoped_weapon_zoomed then
		if (get_console():get_bool("wpn_aim_toggle")) then
			level.press_action(bind_to_dik(key_bindings.kWPN_ZOOM))
		else
			level.release_action(bind_to_dik(key_bindings.kWPN_ZOOM))
		end
	end

	if not tilt_enabled then
		-- Dirty AF hack to reset position (unused)
		-- local wpn_hud = ui_debug_wpn_hud.WpnHudEditor(nil, sec)
		-- if wpn_hud then
		-- 	wpn_hud:Reset(true)
		-- 	wpn_hud:Close()
		-- end
		reset_wpn_hud(sec)

		hud_adjust.enabled(true)
		set_weapon_position(sec, weapon_table[sec].hands_position, weapon_table[sec].hands_orientation)
		
		if debug_enabled() then
			exec_console_cmd("g_firepos 1")
		end

		tilt_enabled = true
	end
end

function reset(sec)
	if tilt_enabled then
		if sec and weapon_table[sec] then reset_wpn_hud(sec) end
		hud_adjust.enabled(false)
		
		if debug_enabled() then
			exec_console_cmd("g_firepos " .. (firepos_state or 0))
		end

		smoothed_values.hands_position_x = nil
		smoothed_values.hands_position_y = nil
		smoothed_values.hands_position_z = nil
		smoothed_values.hands_orientation_x = nil
		smoothed_values.hands_orientation_y = nil
		smoothed_values.hands_orientation_z = nil
		smoothed_values.coeff = nil
		tilt_enabled = false
	end
end

-- Get steps depending on inv_weight, heavier guns have less movement speed
function get_weapon_weight(wpn, sec)
	local cobj = wpn:cast_Weapon()
	local weight = clamp(cobj and cobj:Weight() or (weapon_table[sec] and weapon_table[sec].inv_weight or 0), 0, 20)
	return weight
end

function get_weapon_steps(wpn, sec)
	return settings.animation_speed * (1 + get_weapon_weight(wpn, sec) * (settings.animation_weight_coeff * 0.07))
end

function set_weapon_position(sec, new_pos, new_ori)
	-- printf("old_pos for %s: %s, %s, %s", sec, weapon_table[sec].hands_position[0], weapon_table[sec].hands_position[1], weapon_table[sec].hands_position[2])
	-- printf("new_pos for %s: %s, %s, %s", sec, new_pos[0], new_pos[1], new_pos[2])
	-- printf("old_ori for %s: %s, %s, %s", sec, weapon_table[sec].hands_orientation[0], weapon_table[sec].hands_orientation[1], weapon_table[sec].hands_orientation[2])
	-- printf("new_pri for %s: %s, %s, %s", sec, new_ori[0], new_ori[1], new_ori[2])

	hud_adjust.set_vector(0, 0, new_pos[0] or 0, new_pos[1] or 0, new_pos[2] or 0)
	hud_adjust.set_vector(1, 0, new_ori[0] or 0, new_ori[1] or 0, new_ori[2] or 0)
	-- hud_adjust.set_vector(parameters[parent].idxa, parameters[parent].idxb, value_1, value_2, value_3)
end

function soft_reset(wpn, sec, delta)
	if not weapon_table[sec] then return reset(sec) end

	if tilt_enabled then
		-- k is modifier for ema steps to have more inertia in the beginning of movement
		local k = max(1, 1.5 - (1 - normalize(smoothed_values.hands_orientation_y or max_deg, weapon_table[sec].hands_orientation[1], max_deg)))

		-- Increase speed of return to position when closer to it for zoomed weapons
		local is_scoped = isScopedWeapon(wpn)
		k = k * (is_scoped and normalize(smoothed_values.hands_orientation_y, weapon_table[sec].hands_orientation[1], max_deg) ^ 0.105 or 1)

		-- printf("cur %s, min %s, max %s, %s", smoothed_values.hands_orientation_y, weapon_table[sec].hands_orientation[1], max_deg, k)
		local steps = get_weapon_steps(wpn, sec) * k

		-- Smooth the coeff
		local coeff_smoothing = steps * 0.5
		local coeff = ema("coeff", 0, 0, coeff_smoothing, delta)

		-- Remove random roll and yaw if close to end
		if coeff < 0.5 then
			remove_roll_yaw()
		end

		local new_pos = {
			[0] = ema("hands_position_x", lerp(weapon_table[sec].hands_position[0], smoothed_values.hands_position_x, coeff), weapon_table[sec].hands_position[0], steps, delta),
			[1] = ema("hands_position_y", lerp(weapon_table[sec].hands_position[1], smoothed_values.hands_position_y, coeff), weapon_table[sec].hands_position[1], steps, delta),
			[2] = ema("hands_position_z", lerp(weapon_table[sec].hands_position[2], smoothed_values.hands_position_z, coeff), weapon_table[sec].hands_position[2], steps, delta),
		}

		local new_ori = {
			[0] = ema("hands_orientation_x", lerp(weapon_table[sec].hands_orientation[0], smoothed_values.hands_orientation_x, coeff), weapon_table[sec].hands_orientation[0], steps, delta),
			[1] = ema("hands_orientation_y", lerp(weapon_table[sec].hands_orientation[1], smoothed_values.hands_orientation_y, coeff), weapon_table[sec].hands_orientation[1], steps, delta),
			[2] = ema("hands_orientation_z", lerp(weapon_table[sec].hands_orientation[2], smoothed_values.hands_orientation_z, coeff), weapon_table[sec].hands_orientation[2], steps, delta),
		}

		set_weapon_position(sec, new_pos, new_ori)

		if scoped_weapon_zoomed then
			if (get_console():get_bool("wpn_aim_toggle")) then
				level.press_action(bind_to_dik(key_bindings.kWPN_ZOOM))
			else
				level.release_action(bind_to_dik(key_bindings.kWPN_ZOOM))
			end
		end

		for i = 0, 2, 1 do
			if 	abs(new_pos[i] - weapon_table[sec].hands_position[i]) > 0.055
			or 	abs(new_ori[i] - weapon_table[sec].hands_orientation[i]) > 0.055
			then
				return
			end
		end

		-- printf("soft reset complete")
		reset(sec)
	end
end

local reset_on_show_done = false
function actor_on_update(binder, delta)
	local actor = db.actor

	-- Cancel if PDA is active
	if actor:active_slot() == 8 then
		return reset()
	end

	local wpn = actor:active_item()

	-- printf("%s", delta)

	-- Reset if no wpn
	if not wpn then
		return reset()
	end

	local sec = wpn:section()
	local hud_sec = SYS_GetParam(0, sec, "hud")

	-- Reset when no hud sec
	if not hud_sec then
		return reset(sec)
	end

	-- Reset if melee weapon or binocs
	if IsMelee(wpn) or IsItem("fake_ammo_wpn", sec) or IsBinoc(sec) then
		return reset(sec)
	end

	-- Reset if throwable weapon (grenade, bolt)
	if IsBolt(wpn) or IsGrenade(wpn) then
		return reset(sec)
	end

	-- Add to weapon table
	if not weapon_table[sec] then
		add_to_weapon_table(sec)
	end

	-- Reset HUD once on weapon raise
	local state = wpn:get_state()
	if state == 1 then
		if not reset_on_show_done then
			-- printf("reset on show for %s", sec)
			reset_on_show_done = true
			reset(sec)
		end
	else
		reset_on_show_done = false
	end

	-- Soft reset if weapon is lowered
	if actor_weapon_lowered() then
		return soft_reset(wpn, sec, delta)
	end

	-- Cancel if detector is active
	if actor:active_detector() then
		return soft_reset(wpn, sec, delta)
	end

	-- Soft reset if hiding weapon or reloading
	if state == 2 or state == 7 then
		return soft_reset(wpn, sec, delta)
	end

	-- Get target dist
	local dist = max(0, get_target_dist() - 0.5)
	-- printf("target_dist %s", dist)

	-- Get max dist based on weapon
	-- Check for scopes on weapons
	if not wpn_radii[sec] then
		local parent = SYS_GetParam(0, sec, "parent_section", sec)
		local scopes = str_explode(SYS_GetParam(0, parent, "scopes", ""), ",")
		for k, v in pairs(scopes) do
			if (parent .. "_" .. v) == sec then
				wpn_radii[sec] = wpn_radii[parent]
				break
			end
		end

		-- Add table with 0 offsets if no weapon offset found
		if not wpn_radii[sec] then
			wpn_radii[sec] = 0
		end
	end

	local max_dist = settings.trigger_radius
	max_dist = (SYS_GetParam(0, sec, "kind", "") == "w_pistol" and max_dist - 0.34 or max_dist) + wpn_radii[sec]

	-- Soft reset if distance is more than max_dist
	if dist > max_dist then
		return soft_reset(wpn, sec, delta)
	end

	-- Soft reset if target is enemy stalker or monster
	local target_obj = get_target_obj()
	if target_obj then
		if IsMonster(target_obj) then
			return soft_reset(wpn, sec, delta)
		elseif IsStalker(target_obj) and xr_combat_ignore.is_enemy(actor, target_obj, true) then
			return soft_reset(wpn, sec, delta)
		end
	end

	-- printf("coeff %s, dist %s, max_dist %s", coeff, dist, max_dist)

	-- Calculate new position
	local position_coeff_y = -0.445
	local position_coeff_z = 0.485

	-- Get steps depending on inv_weight, heavier guns have less movement speed
	-- k is modifier for ema steps to have more inertia in the beginning of movement
	local k = max(1, 1.5 - sqrt(normalize(smoothed_values.hands_orientation_y or weapon_table[sec].hands_orientation[1], weapon_table[sec].hands_orientation[1], max_deg)))
	local steps = get_weapon_steps(wpn, sec) * k

	-- Apply non linear coefficient
	local coeff = random_funcs.CircularEaseOutPowered(1 - dist / max_dist, 0.65)

	-- Smooth the coeff
	local coeff_smoothing = steps * 0.5
	coeff = ema("coeff", coeff, 0, coeff_smoothing, delta)
	
	local is_pistol = SYS_GetParam(0, sec, "kind", "") == "w_pistol" and not not_pistol_sec[sec]
	local new_pos
	if wpn_positions.weapon_positions[sec] then
		local p = wpn_positions.weapon_positions[sec]
		new_pos = {
			[0] = lerp(weapon_table[sec].hands_position[0], p.x or weapon_table[sec].hands_position[0], coeff),
			[1] = lerp(weapon_table[sec].hands_position[1], p.y or weapon_table[sec].hands_position[1], coeff),
			[2] = lerp(weapon_table[sec].hands_position[2], p.z or weapon_table[sec].hands_position[2], coeff ^ 3.5),
		}
	else
		-- Check for scopes on weapons
		if not wpn_positions.weapon_offsets[sec] then
			local parent = SYS_GetParam(0, sec, "parent_section", sec)
			local scopes = str_explode(SYS_GetParam(0, parent, "scopes", ""), ",")
			for k, v in pairs(scopes) do
				if (parent .. "_" .. v) == sec then
					wpn_positions.weapon_offsets[sec] = wpn_positions.weapon_offsets[parent]
					break
				end
			end

			-- Add table with 0 offsets if no weapon offset found
			if not wpn_positions.weapon_offsets[sec] then
				wpn_positions.weapon_offsets[sec] = {
					x = 0,
					y = 0,
					z = 0
				}
			end
		end

		local o = {
			[0] = wpn_positions.weapon_offsets[sec].x or 0,
			[1] = wpn_positions.weapon_offsets[sec].y or 0,
			[2] = wpn_positions.weapon_offsets[sec].z or 0,
		}

		-- Interpolate between offseted position and desirable closer to obstacle, looks better, mostly
		-- Different calculations for pistols
		if is_pistol then
			local target_pos = {
				[0] = weapon_table[sec].hands_position[0] + settings.offset_x,
				[1] = target_pos.hands_position_pistol[1] + settings.offset_y,
				[2] = target_pos.hands_position_pistol[2] + settings.offset_z,
			}

			-- local a = {
			-- 	[0] = weapon_table[sec].hands_position[0] + o[0] * coeff,
			-- 	[1] = weapon_table[sec].hands_position[1] + (o[1] + position_coeff_y) * coeff,
			-- 	[2] = weapon_table[sec].hands_position[2] + (o[2] + position_coeff_z) * coeff ^ 2,
			-- }

			local b = {
				[0] = lerp(weapon_table[sec].hands_position[0], (o[0] + target_pos[0]), coeff),
				[1] = lerp(weapon_table[sec].hands_position[1], (o[1] + target_pos[1]), coeff),
				[2] = lerp(weapon_table[sec].hands_position[2], (o[2] + target_pos[2]), coeff ^ 2),
			}

			-- local c = {
			-- 	[0] = lerp(b[0], b[0], coeff),
			-- 	[1] = lerp(b[1], b[1], coeff),
			-- 	[2] = lerp(b[2], b[2], coeff ^ 2),
			-- }

			new_pos = b
		else
			local target_pos = {
				[0] = weapon_table[sec].hands_position[0] + settings.offset_x,
				[1] = target_pos.hands_position_rifle[1] + settings.offset_y,
				[2] = target_pos.hands_position_rifle[2] + settings.offset_z,
			}

			local a = {
				[0] = weapon_table[sec].hands_position[0] + o[0] * coeff,
				[1] = weapon_table[sec].hands_position[1] + (o[1] + position_coeff_y) * coeff,
				[2] = weapon_table[sec].hands_position[2] + (o[2] + position_coeff_z) * coeff ^ 3.5,
			}

			local b = {
				[0] = lerp(weapon_table[sec].hands_position[0], (o[0] + target_pos[0]), coeff),
				[1] = lerp(weapon_table[sec].hands_position[1], (o[1] + target_pos[1]), coeff),
				[2] = lerp(weapon_table[sec].hands_position[2], (o[2] + target_pos[2]), coeff ^ 3.5),
			}

			local c = {
				[0] = lerp(a[0], b[0], coeff),
				[1] = lerp(a[1], b[1], coeff),
				[2] = lerp(a[2], b[2], coeff ^ 3.5),
			}

			new_pos = c
		end
	end

	-- Smooth new position
	new_pos = {
		[0] = ema("hands_position_x", new_pos[0], weapon_table[sec].hands_position[0], steps, delta),
		[1] = ema("hands_position_y", new_pos[1], weapon_table[sec].hands_position[1], steps, delta),
		[2] = ema("hands_position_z", new_pos[2], weapon_table[sec].hands_position[2], steps, delta),
	}

	-- Randomize roll and yaw
	randomize_roll_yaw()
	local new_ori = {
		[0] = ema("hands_orientation_x", weapon_table[sec].hands_orientation[0] + yaw * coeff, weapon_table[sec].hands_orientation[0], steps, delta),
		[1] = ema("hands_orientation_y", weapon_table[sec].hands_orientation[1] + max_deg * coeff, weapon_table[sec].hands_orientation[1], steps, delta),
		[2] = ema("hands_orientation_z", weapon_table[sec].hands_orientation[2] + roll * coeff, weapon_table[sec].hands_orientation[2], steps, delta),
	}

	-- Adjust hud
	enable_tilt(sec, wpn)
	set_weapon_position(sec, new_pos, new_ori)
end

function actor_on_weapon_zoom_in(obj)
	scoped_weapon_zoomed = isScopedWeapon(obj)
end

function actor_on_weapon_zoom_out(obj)
	scoped_weapon_zoomed = false
end

function reset_settings()
	load_settings()
	if settings.enabled then
		RegisterScriptCallback("actor_on_update", actor_on_update)
	else
		local sec
		if db.actor then
			local wpn = db.actor:active_item()
			sec = wpn and wpn:section()
		end
		reset(sec)
		UnregisterScriptCallback("actor_on_update", actor_on_update)
	end
end

function actor_on_first_update()
	-- firepos_state = debug_enabled() and get_console_cmd(0, "g_firepos") or 0
	firepos_state = 0
	reset_settings()
end

-- Reset without parameter, for callbacks
function reset_func()
	reset()
end

function on_game_start()
	RegisterScriptCallback("on_option_change", reset_settings)
	RegisterScriptCallback("actor_on_before_death", reset_func)
	RegisterScriptCallback("actor_on_net_destroy", reset_func)
	RegisterScriptCallback("on_before_level_changing", reset_func)
	RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
	RegisterScriptCallback("actor_on_update", actor_on_update)
	RegisterScriptCallback("actor_on_weapon_zoom_in", actor_on_weapon_zoom_in)
	RegisterScriptCallback("actor_on_weapon_zoom_out", actor_on_weapon_zoom_out)
end
